// +build gen

package main

import (
	"bytes"
	"encoding/csv"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"strings"
)

func main() {
	{
		rsp, err := http.Get("https://www.iana.org/assignments/ipv4-address-space/ipv4-address-space.csv")
		if err != nil {
			log.Fatalf("error opening url: %s", err)
		}
		defer rsp.Body.Close()

		cr := csv.NewReader(rsp.Body)
		buf := &bytes.Buffer{}
		gen(cr, buf, false)
		fmtted, err := format.Source(buf.Bytes())
		if err != nil {
			log.Fatalf("error formatting source: %s", err)
		}
		if err := ioutil.WriteFile("v4table.go", fmtted, 0644); err != nil {
			log.Fatalf("error creating output: %s", err)
		}
	}
	{
		rsp, err := http.Get("https://www.iana.org/assignments/ipv6-unicast-address-assignments/ipv6-unicast-address-assignments.csv")
		if err != nil {
			log.Fatalf("error opening url: %s", err)
		}
		defer rsp.Body.Close()

		cr := csv.NewReader(rsp.Body)
		buf := &bytes.Buffer{}
		gen(cr, buf, true)
		fmtted, err := format.Source(buf.Bytes())
		if err != nil {
			log.Fatalf("error formatting source: %s", err)
		}
		if err := ioutil.WriteFile("v6table.go", fmtted, 0644); err != nil {
			log.Fatalf("error creating output: %s", err)
		}
	}
}

func parseCIDR(cidr string) (*net.IPNet, error) {
	// 222/2 -> 222.0.0.0/8
	if strings.HasSuffix(cidr, "/8") {
		cidr = cidr[:len(cidr)-2] + ".0.0.0/8"
	}
	_, ipn, err := net.ParseCIDR(cidr)

	return ipn, err
}

func gen(cr *csv.Reader, buf io.Writer, v6 bool) {
	fmt.Fprintln(buf, "package ripelookup")
	fmt.Fprintln(buf, "// code generated by gen.go DO NOT EDIT")
	fmt.Fprintln(buf, `import "github.com/kentik/patricia"`)
	fmt.Fprintln(buf, `import "github.com/kentik/patricia/string_tree"`)
	if v6 {
		fmt.Fprintln(buf, "var v6tree = string_tree.NewTreeV6()")
	} else {
		fmt.Fprintln(buf, "var v4tree = string_tree.NewTreeV4()")
	}
	fmt.Fprintln(buf, "func init() {")
	initial := true
	for {
		rec, err := cr.Read()
		if err == io.EOF {
			break
		}
		if err != nil {
			log.Fatalf("error reading csv: %s", err)
		}
		// skip the first line
		if initial {
			initial = false
			continue
		}
		pfx := rec[0]
		whois := rec[3]
		if whois == "" {
			continue
		}

		ipn, err := parseCIDR(pfx)
		if err != nil {
			log.Fatalf("error parsing cidr %s: %s", pfx, err)
		}
		bits, _ := ipn.Mask.Size()
		if v6 {
			fmt.Fprintf(buf, "  // %s\n", ipn)
			fmt.Fprintf(buf, `  v6tree.Set(patricia.NewIPv6Address([]byte{`)
			for i := 0; i < 16; i++ {
				if i != 0 {
					fmt.Fprintf(buf, ",")
				}
				fmt.Fprintf(buf, "%d", ipn.IP[i])
			}
			fmt.Fprintf(buf, `},%d),"%s")`, bits, whois)
		} else {
			fmt.Fprintf(buf, `  v4tree.Set(patricia.NewIPv4AddressFromBytes([]byte{%d,%d,%d,%d},%d),"%s")`, ipn.IP[0], ipn.IP[1], ipn.IP[2], ipn.IP[3], bits, whois)
		}
		fmt.Fprintln(buf)
	}
	fmt.Fprintln(buf, "}")
}
